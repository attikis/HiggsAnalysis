#!/bin/csh

#@$-r  h2tau   # request name
#@$-lf 90mb     # output file size limit
#@$-eo          # direct stderr output to the stdout destination
#-me          # send mail upon termination
#@$-s /bin/csh
#@$

#	setenv ROOTFILEPATH rfio:$CASTOR_HOME/hch300_tauola_HLT
#	setenv ROOTFILE HLTtable_hch300_tauola_1.root
        setenv ROOTFILEPATH rfio:/castor/cern.ch/cms/store/relval/CMSSW_2_1_9/RelValTTbar/GEN-SIM-DIGI-RAW-HLTDEBUG-RECO/IDEAL_V9_Tauola_v1/0002/
        setenv ROOTFILE 008F0E5C-5C8E-DD11-A113-001617C3B6DC.root

	setenv CASTOR_DIR test

        if( $%1 > 0 ) then
                setenv ROOTFILEPATH $1
                setenv ROOTFILE $2
        endif

        echo ${ROOTFILEPATH}
        echo ${ROOTFILE}

        if( $ENVIRONMENT != "BATCH" ) then
          echo Setting workdir to SCRATCH
          setenv WORKDIR $TMP
          setenv LS_SUBCWD $PWD
        endif

        cd ${LS_SUBCWD}
        echo "Setting runtime environment"
        eval `scramv1 runtime -csh`

	cd ${WORKDIR}

        if ( -f $WORKDIR/analysis_${ROOTFILE}.cfg ) rm -f $WORKDIR/analysis_${ROOTFILE}.cfg
        cat > $WORKDIR/analysis_${ROOTFILE}.cfg <<END_OF_CONFIG

process test = {

    untracked PSet maxEvents = {untracked int32 input = 10}
 
    source = PoolSource {
	untracked vstring fileNames = {'${ROOTFILEPATH}/${ROOTFILE}'}
    }

    include "RecoParticleFlow/Configuration/data/RecoParticleFlow.cff"
    include "RecoBTau/JetTracksAssociator/data/pfJetTracksAssociator.cfi"
    include "RecoTauTag/RecoTau/data/PFRecoTauTagInfoProducer.cfi"
    replace pfRecoTauTagInfoProducer.ChargedHadrCand_tkminPt = 0
    replace pfRecoTauTagInfoProducer.tkminPt = 0
    include "RecoTauTag/RecoTau/data/PFRecoTauProducer.cfi"
    replace pfRecoTauProducer.ChargedHadrCand_minPt = 0
    replace pfRecoTauProducer.NeutrHadrCand_minPt = 0
    replace pfRecoTauProducer.GammaCand_minPt = 0
    replace pfRecoTauProducer.Track_minPt = 0
    include "RecoTauTag/RecoTau/data/PFRecoTauDiscriminationByIsolation.cfi"
    path pftau={particleFlowJetCandidates,iterativeCone5PFJets,pfJetTracksAssociator,pfRecoTauTagInfoProducer,pfRecoTauProducer}

    # Message Logger
    include "FWCore/MessageLogger/data/MessageLogger.cfi"

    # Magnetic Field
    include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"

    include "RecoJets/JetProducers/data/iterativeCone5CaloJets.cff"
    include "RecoBTau/JetTracksAssociator/data/jetTracksAssociator.cfi"
    include "RecoTauTag/RecoTau/data/CaloRecoTauTagInfoProducer.cfi"
    replace caloRecoTauTagInfoProducer.tkminPt = 0
    include "RecoTauTag/RecoTau/data/CaloRecoTauProducer.cfi"
    replace caloRecoTauProducer.Track_minPt = 0
    include "RecoTauTag/RecoTau/data/CaloRecoTauDiscriminationByIsolation.cfi"
    path tau = {iterativeCone5CaloJets,jetTracksAssociator,caloRecoTauTagInfoProducer,caloRecoTauProducer}

    # XML ideal geometry description
    include "Geometry/CMSCommonData/data/cmsIdealGeometryXML.cfi"
    # Calo geometry service model
    include "Geometry/CaloEventSetup/data/CaloGeometry.cfi"
    # Calo topology service model
    include "Geometry/CaloEventSetup/data/CaloTopology.cfi"
    include "TrackingTools/TransientTrack/data/TransientTrackBuilder.cfi"

    include "JetMETCorrections/MCJet/data/MCJetCorrections152.cff"
    es_prefer MCJetCorrectorMcone5 = MCJetCorrectionService {}

    include "RecoMET/METProducers/data/CaloMET.cfi"
    path missingEt = {metNoHF}

    include "JetMETCorrections/Type1MET/data/MetType1Corrections.cff"
    path missingEt_type1i = {corMetType1Icone5}
    path missingEt_type1m = {corMetType1Mcone5}

    module corMetType1Icone5NoHF = Type1MET {
            string metType = "CaloMET"
            string inputUncorMetLabel  = "metNoHF"
            string inputUncorJetsLabel = "iterativeCone5CaloJets"
            string corrector           = "MCJetCorrectorIcone5"
            double jetPTthreshold      = 20.0
            double jetEMfracLimit      = 0.9
    }
    path missingEt_type1i_nohf = {corMetType1Icone5NoHF}

    module corMetType1Mcone5NoHF = Type1MET {
            string metType = "CaloMET"
            string inputUncorMetLabel  = "metNoHF"
            string inputUncorJetsLabel = "midPointCone5CaloJets"
            string corrector           = "MCJetCorrectorMcone5"
            double jetPTthreshold      = 20.0
            double jetEMfracLimit      = 0.9
    }
    path missingEt_type1m_nohf = {corMetType1Mcone5NoHF}

    include "RecoTracker/TransientTrackingRecHit/data/TransientTrackingRecHitBuilderWithoutRefit.cfi"

    # iterative tracking
    include "Configuration/StandardSequences/data/Reconstruction.cff"
    include "Configuration/StandardSequences/data/FakeConditions.cff"
    include "Configuration/StandardSequences/data/Simulation.cff"
    include "Configuration/StandardSequences/data/MixingNoPileUp.cff"
    include "Configuration/StandardSequences/data/VtxSmearedGauss.cff"
    include "RecoParticleFlow/PFTracking/data/iterativeTk.cff"

    module iterativeTracks = IterativeTrackCollectionProducer{}
    path iterativeTracking = {iterativeTk,iterativeTracks}


    include "EgammaAnalysis/ElectronIDProducers/data/cutBasedElectronId.cfi"
    include "EgammaAnalysis/ElectronIDProducers/data/ptdrElectronId.cfi"

    module offlineAnalysis = OfflineAnalysis {

        //VInputTag HLTSelection = {HLT1Tau,HLT1MuonIso}
        VInputTag HLTSelection = {HLT1Tau,HLT1MuonIso,HLT1MET,HLT1Tau1MET,HLT1jet,HLT2jet,HLT3jet,HLT4jet}

        // JetEnergyCorrection = MCJetCorrectorIcone5,MCJetCorrectorMcone5
	// if no corrections, leave {} empty
        VInputTag JetEnergyCorrection = {MCJetCorrectorIcone5,MCJetCorrectorMcone5}

        // b tagging elgorithms
        VInputTag BTaggingAlgorithms = {
                trackCountingHighPurJetTags,
                trackCountingHighEffJetTags,
                jetProbabilityJetTags,
                softElectronJetTags,
                softMuonJetTags,
                softMuonNoIPJetTags
        }

        //TrackCollection = ctfWithMaterialTracks,iterativeTracks
        InputTag TrackCollection = iterativeTracks

	//TauJet calibration
	InputTag src = iterativeCone5CaloJets
	string tagName = 'IterativeCone0.4_EtScheme_TowerEt0.5_E0.8_Jets871_2x1033PU_tau'
	int32 TauTriggerType = 1

        // Electron identification
        # Selection of input variables:
        bool useEoverPIn      = 1
        bool useDeltaEtaIn    = 1
        bool useDeltaPhiIn    = 1
        bool useHoverE        = 1
        bool useE9overE25     = 1
        bool useEoverPOut     = 1
        bool useDeltaPhiOut   = 1
        bool useInvEMinusInvP = 0
        bool useBremFraction  = 0
        bool useSigmaEtaEta   = 1
        bool useSigmaPhiPhi   = 1

        InputTag barrelClusterShapeAssociation = hybridSuperClusters:hybridShapeAssoc
        InputTag endcapClusterShapeAssociation = islandBasicClusters:islandEndcapShapeAssoc

    	VPSet algo_psets = {
            {using PTDR_ID}, {using CutBased_ID}
    	}
        # Electron quality for cut based ID. Can be:
        # "loose"  - e.g. suitable for H->ZZ->4l
        # "medium" - intermediate quality
        # "tight"  - e.g. suitable for H->WW->2l2nu
        string electronQuality = "loose"

        PSet looseEleIDCuts = {
            vdouble EoverPInMax    = { 1.3,   1.2,   1.3,   999.,  999.,  999.,  999.,  999.  }
            vdouble EoverPInMin    = { 0.9,   0.9,   0.9,   0.6,   0.9,   0.9,   0.9,   0.7   }
            vdouble deltaEtaIn     = { 0.004, 0.006, 0.005, 0.007, 0.007, 0.008, 0.007, 0.008 }
            vdouble deltaPhiIn     = { 0.04,  0.07,  0.04,  0.08,  0.06,  0.07,  0.06,  0.07  }
            vdouble HoverE         = { 0.06,  0.05,  0.06,  0.14,  0.1,   0.1,   0.1,   0.12  }
            vdouble E9overE25      = { 0.7,   0.75,  0.8,   0.,    0.85,  0.75,  0.8,   0.    }
            vdouble EoverPOutMax   = { 2.5,   999.,  999.,  999.,  2.,    999.,  999.,  999.  }
            vdouble EoverPOutMin   = { 0.6,   1.8,   1.,    0.75,  0.6,   1.5,   1.,    0.8   }
            vdouble deltaPhiOut    = { 0.011, 999.,  999.,  999.,  0.02,  999.,  999.,  999.  }
            vdouble invEMinusInvP  = { 0.02,  0.02,  0.02,  0.02,  0.02,  0.02,  0.02,  0.02  }
            vdouble bremFraction   = { 0.,    0.1,   0.1,   0.1,   0.,    0.2,   0.2,   0.2   }
            vdouble sigmaEtaEtaMax = { 0.011, 0.011, 0.011, 0.011, 0.022, 0.022, 0.022, 0.3   }
            vdouble sigmaEtaEtaMin = { 0.005, 0.005, 0.005, 0.005, 0.008, 0.008, 0.008, 0.    }
            vdouble sigmaPhiPhiMax = { 0.015, 999.,  999.,  999.,  0.02,  999.,  999.,  999.  }
            vdouble sigmaPhiPhiMin = { 0.005, 0.,    0.,    0.,    0.,    0.,    0.,    0.    }
        }

    }

    # module execution
    path runEDAna = { offlineAnalysis }
/*
    module poolOutput = PoolOutputModule {
        untracked string fileName = "events.root"
        untracked vstring outputCommands = {
                "keep *",
                "drop *_TriggerResults_*_Rec",
                "drop *_TriggerResults_*_filter",
                "drop recoTaus_*_*_Rec",
                "keep *_source_*_*"
        }
    }
    endpath PoolOutput = {poolOutput}
*/
}
END_OF_CONFIG

        cat ${WORKDIR}/analysis_${ROOTFILE}.cfg

        if( -f ${WORKDIR}/analysis_${ROOTFILE}.out ) mv ${WORKDIR}/analysis_${ROOTFILE}.out ${WORKDIR}/analysis_${ROOTFILE}.out_old
        cmsRun ${WORKDIR}/analysis_${ROOTFILE}.cfg
#       cmsRun ${WORKDIR}/analysis_${ROOTFILE}.cfg >& ${WORKDIR}/analysis_${ROOTFILE}.out

#ls ${WORKDIR} -lt

        if( -f ${WORKDIR}/analysis_${ROOTFILE}.out ) rfcp ${WORKDIR}/analysis_${ROOTFILE}.out ${CASTOR_HOME}/${CASTOR_DIR}
        if( -f ${WORKDIR}/analysis.root ) then
		mv ${WORKDIR}/analysis.root ${WORKDIR}/analysis_${ROOTFILE}
####		rfcp ${WORKDIR}/analysis_${ROOTFILE} ${CASTOR_HOME}/${CASTOR_DIR}
		mv ${WORKDIR}/analysis_${ROOTFILE} $LS_SUBCWD
	endif
